<html>
<head>
    <title> Kathmandu Public Transport </title>
<link rel="stylesheet" href="lib/leaflet/leaflet.css" />
<!--[if lte IE 8]>
    <link rel="stylesheet" href="lib/leaflet/leaflet.ie.css" />
<![endif]-->
<style>
body {
  margin:0;
}
#error {
  position: absolute;
  bottom: 0;
  right: 0;
  height: 200px;
  background-color: black;
  color: #00ff00;
  width: 100%;
  overflow: auto;
}
#errorLog li:hover {
  background-color: #111;
  color: red;
  cursor: pointer;
}
#routepicker {
  position: absolute;
  top: 0;
  right: 0;
}
</style>
<script src="lib/jquery-1.7.2.min.js"></script>
<script src="lib/underscore-min.js"></script>
<script src="lib/leaflet/leaflet.js"></script>
<script src="lib/kdtree/src/web/kdTree.js"></script>
<script src="yatayat.js"></script>
<script src="config.js"></script>
</head>
<body>
<div id="publicTransportMap" style="width: 100%; height: 100%">Loading ...</div>
<pre id="error"><b>WARNINGS</b><ol id="errorLog"> </ol></pre>
<select id="routepicker"></select>
<script type="text/javascript" language="javascript">
// initialize the map
var map = new L.Map('publicTransportMap'),
renderLayer,
sys;

function routeToggler(system) {
    var $rp = $('#routepicker')
        .change(function() {
            if(renderLayer) {
                map.removeLayer(renderLayer);
            }
            console.log('YY.error_render(',sys, sys.routes[$rp[0].selectedIndex], document.getElementById('errorLog'));
            renderLayer = YY.error_render(sys, sys.routes[$rp[0].selectedIndex], document.getElementById('errorLog'));
            map.addLayer(renderLayer);
        });
    system.routes.forEach(function(route) {
        var $opt = $('<option>')
            .html(route.name)
            .appendTo($rp);
    });
}

$.ajax({ type: YY.GET_OR_POST, url: YY.API_URL,
         data: YY.QUERY_STRING,
         dataType: 'text',
         success: function(data) {
             sys = YY.fromOSM(data);
             routeToggler(sys);
	     renderLayer = YY.error_render(sys, sys.routes[0], document.getElementById('errorLog'));
             map.addLayer(renderLayer);
         }});

if(YY.TILE_SOURCE) {
    var tiles = new L.TileLayer(YY.TILE_SOURCE, {
        attribution: YY.ATTRIBUTION,
        maxZoom: 18
    });

    // add the layer to the map, set the view to a given place and zoom
    map.addLayer(tiles);
}

map.setView(new L.LatLng(YY.LAT, YY.LNG), 13);

var SAME_STOP_DIST = Math.pow(0.0005,2);

YY.error_render = function(system, route, log) {

function nearbyDifferentStops(system, route) {
    stopClosest = {};

    route.stops.forEach(function(stop) {
        var stops = system.nearestStops([stop.lat, stop.lng], 2, SAME_STOP_DIST)
            .filter(function(s) { return s.id !== stop.id; });
        if(stops.length > 0 && stop.name && stops[0].name && stops[0].name !== stop.name) {
            stopClosest[stop.id] = stops[0];
        }
    });

    return stopClosest;
}

function unnamedStops(route) {
    unnamedStops = {};

    route.stops.forEach(function(stop) {
        if(!stop.name) {
            unnamedStops[stop.id] = true;
            }
    });

    return unnamedStops;
}

function similarNames(system, route) {
    // thanks! http://thinkphp.ro/apps/js-hacks/String.levenshtein/String.levenshtein.html
    var levenshtein = function(stringa, stringb) {
        var cost = new Array(),
        str1 = stringa,
        str2 = stringb,
        n = str1.length,
        m = str2.length,
        i, j;
        var minimum = function(a,b,c) {
            var min = a;
            if(b < min) {
                min = b;
            }
            if(c < min) {
                min = c;
            }
            return min;
        }

        if(n == 0 || m == 0) {
            return;  
        } 

        for(var i=0;i<=n;i++) {
            cost[i] = new Array();
        }

        for(i=0;i<=n;i++) {
            cost[i][0] = i;
        }

        for(j=0;j<=m;j++) {
            cost[0][j] = j;
        }

        for(i=1;i<=n;i++) {
            var x = str1.charAt(i-1);
            for(j=1;j<=m;j++) {
                var y = str2.charAt(j-1);
                if(x == y) {
                    cost[i][j] = cost[i-1][j-1]; 
                } else {
                    cost[i][j] = 1 + minimum(cost[i-1][j-1], cost[i][j-1], cost[i-1][j]);
                } 
            }
        }
        return cost[n][m];  
    };

    var preprocess = function(str) {
        return str.toLowerCase().replace(' ', '');
    };

    similarNames = {};

    // n^2 algorithm that compares string-distance between every two pairs of stop
    route.stops.forEach(function(stop) {
            
        system.routes.forEach(function(route2) {
            route.stops.forEach(function(stop2) {

                if(stop.name && stop2.name && levenshtein(stop.name, stop2.name) < 3) {
                    var physicalDistance = Math.pow(stop.lat-stop2.lat,2) + Math.pow(stop.lng-stop2.lng,2);
                    if(physicalDistance > SAME_STOP_DIST) {
                        // console.log(stop.name, stop2.name, physicalDistance);
                        similarNames[stop.id] = stop2;
                    }
                    else if(stop.id != stop2.id) {
                        //console.log(stop.name, stop2.name, 'nearby');
                    }
                }
                
            });
        });
    });
    return similarNames;
}

var noTerminus = function(route) {
    return false ||  route._noTerminus;
};

var unconnectedSegments = function(route) {
    unconnected = {};
    /*var last_seg = null;
    route.segments.forEach(function(segment) {
        if(last_seg) {
            var s1f = segment.listOfLatLng[0];
            var s1r = segment.listOfLatLng[segment.listOfLatLng.length-1];
            var s2f = last_seg.listOfLatLng[0];
            var s2r = last_seg.listOfLatLng[last_seg.listOfLatLng.length-1];
            
            // Something is wrong in the order() call.
            // Let's just check all pairs of starts and ends.
            if(!(_.isEqual(s1f, s2f) || _.isEqual(s1f, s2r) || 
                 _.isEqual(s1r, s2f) || _.isEqual(s1r, s2r))) {
                unconnected[last_seg.id] = segment;
            }
        }
        last_seg = segment;
    });*/
    route._unconnectedSegments.forEach(function(seg) {
        unconnected[seg.id] = true;
    });
    return unconnected;
};

    var layer = new L.LayerGroup();
    log.innerHTML = "";

    // Check for four classes of errors

    // 1. Nearby stops (are they the same?)
    var nearby = nearbyDifferentStops(system, route);
    var nearbycol = 'yellow';

    // 2. Unnamed stop
    var unnamed = unnamedStops(route);
    var unnamedcol = 'black';

    // 3. Similarly-named stop (that are far away)
    var simnames = similarNames(system, route);
    var simnamescol = 'magenta';

    // 4.1 Routes without a start / terminus
    var noTerminus = noTerminus(route);

    // 4.2 Unconnected segments (show only if terminus found)
    var unconnected = unconnectedSegments(route);
    var unconnectedcol = 'red';

    // 5. Stops with the same name one after another
    // XXX: TODO


    var addLog = function(msg, latlng, marker) {
        var $msg = document.createElement('li');
        $msg.innerHTML = msg;

        var pop = function() { 
            var popup = new L.Popup();
            popup.setLatLng(latlng);
            popup.setContent(msg);
            map.openPopup(popup);
        };
        $msg.onclick = pop;
        marker.on('click', pop);
        log.appendChild($msg);
    }
    _.each(route.segments,function(seg, idx) {
        if(seg.id in unconnected) {
            var latlngs = seg.listOfLatLng.map(function(LL) { return new L.LatLng(LL[0], LL[1]); });
            var poly = new L.Polyline(latlngs, {color: unconnectedcol});
            if (noTerminus && !idx) {
                var msg = "no start-point (or terminus) defined";
                addLog(msg, latlngs[Math.floor(latlngs.length / 2)], poly);
            } else if (!noTerminus) {
                var msg = "unconnected segment";
                addLog(msg, latlngs[Math.floor(latlngs.length / 2)], poly);
            }
            layer.addLayer(poly);

            // var seg2 = unconnected[seg.id];
            // var ll2 = seg2.listOfLatLng.map(function(LL) {return new L.LatLng(LL[0], LL[1]);});
            // var poly2 = new L.Polyline(ll2, {color: 'black'});
            // layer.addLayer(poly2);
            // delete unconnectedcol[seg.id]; // don't draw twice;
        }
        else {
            var latlngs = seg.listOfLatLng.map(function(LL) { return new L.LatLng(LL[0], LL[1]); });
            var poly = new L.Polyline(latlngs, {color: 'green'});
            layer.addLayer(poly);
        }
    });

    route.stops.forEach(function(stop) {
        var marker;
        var ll = new L.LatLng(stop.lat, stop.lng);
        if(stop.id in nearby) {
            marker = new L.CircleMarker(ll,
                                        {color: nearbycol});
            var routename = "";
            for(var rid in nearby[stop.id].routeDict) {
                routename = nearby[stop.id].routeDict[rid].name;
            }
            var msg = stop.name + " is rather close to " + nearby[stop.id].name + " (in route: "+ routename + ") but they have different names";
            addLog(msg, ll, marker);
        }
        else if(stop.id in unnamed) {
            marker = new L.CircleMarker(ll,
                                        {color: unnamedcol});
            var msg = "unnamed stop";
            addLog(msg, ll, marker);
        }
        else if(stop.id in simnames) {
            marker = new L.CircleMarker(ll,
                                        {color: simnamescol});
            var routename = "";
            for(var rid in simnames[stop.id].routeDict) {
                routename = simnames[stop.id].routeDict[rid].name;
            }
            var msg = stop.name + " has a similar name to far-off stop " + simnames[stop.id].name + ' (in route: ' + routename + ")";
            addLog(msg, ll, marker);
        }
        else {
            marker = new L.CircleMarker(ll,
                                        {color: 'green', opacity:0.2});
        }
        if(marker)
            layer.addLayer(marker);
    });

    return layer;
};

</script>
</body>
</html>
